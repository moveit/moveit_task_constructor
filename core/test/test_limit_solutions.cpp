#include <moveit/task_constructor/container_p.h>
#include <moveit/task_constructor/stage_p.h>
#include <moveit/task_constructor/task_p.h>
#include <moveit/task_constructor/stages/limit_solutions.h>
#include <moveit/task_constructor/stages/noop.h>
#include <moveit/planning_scene/planning_scene.hpp>

#include "stage_mockups.h"
#include "models.h"
#include "gtest_value_printers.h"

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <initializer_list>
#include <chrono>
#include <thread>

using namespace moveit::task_constructor;

using LimitSolutionsFixtureGenerator = TaskTestBase;

TEST_F(LimitSolutionsFixtureGenerator, returnsMaxSolutions) {
	auto g = std::make_unique<GeneratorMockup>(PredefinedCosts({ 2.0, 1.0, 3.0 }));
    auto ls = std::make_unique<stages::LimitSolutions>("LimitSolutions", std::move(g));
	ls->setMaxSolutions(2);
    t.add(std::move(ls));

	EXPECT_TRUE(t.plan());
	EXPECT_EQ(t.solutions().size(), 2u);
}

TEST_F(LimitSolutionsFixtureGenerator, returnsAllChildSolutionsIfFewerThanMax) {
	auto g = std::make_unique<GeneratorMockup>(PredefinedCosts({ 2.0, 1.0, 3.0 }));
    auto ls = std::make_unique<stages::LimitSolutions>("LimitSolutions", std::move(g));
	ls->setMaxSolutions(5);
    t.add(std::move(ls));

	EXPECT_TRUE(t.plan());
	EXPECT_EQ(t.solutions().size(), 3u);
}

TEST_F(LimitSolutionsFixtureGenerator, returnsBestSolutions) {
    // generator can create solutions with costs 1-10 in a single call to compute
	auto g = std::make_unique<GeneratorMockup>(PredefinedCosts({ 10.0, 7.0, 8.0, 6.0, 9.0, 2.0, 1.0, 3.0, 4.0, 5.0 }), 10);

    auto ls = std::make_unique<stages::LimitSolutions>("LimitSolutions", std::move(g));
	ls->setMaxSolutions(5);
    t.add(std::move(ls));

	EXPECT_TRUE(t.plan());
	EXPECT_EQ(t.solutions().front()->cost(), 1.0);
}

TEST_F(LimitSolutionsFixtureGenerator, returnsBestAvailableSolutions) {
	// generator can create solutions with costs 1-10, will return one solution per compute
    auto g = std::make_unique<GeneratorMockup>(PredefinedCosts({ 10.0, 7.0, 8.0, 6.0, 9.0, 2.0, 1.0, 3.0, 4.0, 5.0 }), 1);	
    uint called = 0;
	auto cb = [&called](const SolutionBase& /* s */) {
		++called;
		return true;
	};
	g->addSolutionCallback(cb);
    
    auto ls = std::make_unique<stages::LimitSolutions>("LimitSolutions", std::move(g));
	ls->setMaxSolutions(5);
    t.add(std::move(ls));

	EXPECT_TRUE(t.plan());
    // best available solution was 6.0
	EXPECT_EQ(t.solutions().front()->cost(), 6.0);
    // only five solutions should have been generated by the generator
    EXPECT_EQ(called, 5u);
}

TEST_F(LimitSolutionsFixtureGenerator, limitsNumberOfPropagatorCalls) {
    // generator can create solutions with costs 1-10 in a single call to compute
	auto g = std::make_unique<GeneratorMockup>(PredefinedCosts({ 10.0, 7.0, 8.0, 6.0, 9.0, 2.0, 1.0, 3.0, 4.0, 5.0 }), 10);

    auto p = std::make_unique<PropagatorMockup>();
    uint p_called = 0;
	auto cb = [&p_called](const SolutionBase& /* s */) {
		++p_called;
		return true;
	};
	p->addSolutionCallback(cb);

    auto ls = std::make_unique<stages::LimitSolutions>("LimitSolutions", std::move(p));
    ls->setMaxSolutions(2);

    t.add(std::move(g));
    t.add(std::move(ls));
    
    EXPECT_TRUE(t.plan());
    // only two solutions should have been generated by the propagator
    EXPECT_EQ(p_called, 2u);
}

